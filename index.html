<html>
<head>
    <link rel="prefetch" href="clock.html">
    <link rel="stylesheet" href="styles.css">
    <title>hamed</title>
    <link href="" rel="import" />
    <style>
     body {
    width: 100%;
    height: 100vh;
    background-color: #000;
    background-image: radial-gradient(circle at top right, rgba(121, 68, 154, 0.13),       transparent),
      radial-gradient(circle at 20% 80%, rgba(41, 196, 255, 0.13), transparent)
  }
  canvas {
    position: fixed;
    width: 100%;
    height: 100%;
  }
  
  a {
    position: absolute;
    bottom: 2vmin;
    right: 2vmin;
    color: rgba(255,255,255,0.2);
    text-decoration: none;
  }
  
  a:hover {
    color: red;
  }
    </style>
</head>
<body>
    <canvas></canvas>

    <div w3-include-html="
                          
                          
                          
                          
                        <html lang="en">

<head>
    <style>
    
    @font-face {
    font-family: 'DS-DIGI';
    src: url('DS-DIGI.TTF');
}



:root {
    --clockSize: 30rem;
    --bgColor: #111;
    --mainColor: #37f;
    --loadingSize: 0;
    --dashArray: 876;
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

html {
    font-size: 62.5%;
}

body {
    background: var(--bgColor);
    font-family: 'DS-DIGI', sans-serif;
}

.container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    width: 100%;
    min-height: 100vh;
}

.box {
    margin: 0;
    padding: 0;
    position: relative;
    margin-top: 10rem;
}

.clock-container {
    background: transparent;
    margin: 0;
    padding: 0;
    width: var(--clockSize);
    height: var(--clockSize);
    display: flex;
    align-items: center;
    justify-content: center;
}

.clock-shape {
    fill: transparent;
    stroke-width: calc(var(--clockSize) * 0.05);
    stroke: rgba(255, 255, 255, 0.1);
    stroke-dasharray: var(--dashArray);
    stroke-dashoffset: 0;
    stroke-linecap: round;
    transition: 1s;
}

.main-circle {
    stroke: var(--mainColor);
    stroke-dashoffset: calc(var(--dashArray) - (var(--dashArray) * (var(--loadingSize) / 60)));
}

.content {
    color: var(--mainColor);
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 5.5rem;
}

.sec {
    animation: secAnimation 1s infinite;
}

@keyframes secAnimation {
    from {
        opacity: 0;
    }

    to {
        opacity: 1;
    }
}

footer {
    color: #fff;
    margin-top: 20rem;
    font-size: 2rem;
}

.link {
    color: var(--mainColor);
    text-decoration: none;
}

@media (max-width: 300px) {
    html {
        font-size: 40.5%;
    }

    :root {
        --dashArray: 565;
    }
}

    
    </style>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Rounded Clock(by hamed sepehrnia)</title>

    <link rel="stylesheet" href="style.css">
</head>

<body onload="resizeClock()">
    

    <main class="container">
        <div class="box">
            <svg class="clock-container">
                <circle class="clock-shape"></circle>
                <circle class="clock-shape main-circle"></circle>
            </svg>
            <div class="content">
                <span class="time hour">
                    12
                </span>
                <b class="colon">:</b>
                <span class="time min">
                    00
                </span>
            </div>
        </div>
        <footer>
            made by Hamed sepehrnia
        </footer>
    </main>
    <script>
    
    'use strict';

function resizeClock() {
    //    COLLECTING ALL DATAS FROM HTML
    var circle = document.querySelectorAll('.clock-shape');
    var clockSize = getComputedStyle(document.documentElement).getPropertyValue('--clockSize');
    var circleSize = 'calc(' + clockSize + ' / 2)';
    var circleRadius = 'calc((' + clockSize + ' / 2) - 1rem)';

    //    RESIZING THE CIRCLE SIZE ACRODING TO THE SVG SIZE
    for (let i = 0; i < circle.length; i++) {
        circle[i].setAttribute('cy', circleSize);
        circle[i].setAttribute('cx', circleSize);

        circle[i].setAttribute('r', circleRadius);
    }
}

clockFun()

function clockFun() {
    //    GETTING THE TIME 
    let time = new Date();
    let hour = time.getHours();
    let sec = time.getSeconds();
    let min = time.getMinutes();
    //    STYLING THE HOURS AND MINUTES
    hour = (hour > 12) ? hour - 12 : hour;
    hour = (hour < 10) ? '0' + hour : hour;
    min = (min < 10) ? '0' + min : min;

    //    UPDATEING THE CIRCLE LOADER VALUE WITH SECONDS
    document.documentElement.style.setProperty('--loadingSize', sec);
    //    SELECTING THE HOUR, MINUTE AND COLON
    const hourTxt = document.querySelector('.hour');
    const minTxt = document.querySelector('.min');
    var colon = document.querySelector('.colon');
    //    UPDATING THEM WITH HOUR AND MINUTE VALUE
    hourTxt.innerHTML = hour;
    minTxt.innerHTML = min;
    //    ADDING SIMPLE SECOND EFFECT TO THE COLON
    if (!colon.classList.contains('sec')) {
        colon.classList.add('sec')
    }
    //    CALLING THIS FUNCTION TO UP TO DATE THE TIME
    setInterval(clockFun, 1000);
}

    
    
    </script>
</body>

</html>
  
                          
                          
                          
                          
                          
                          
                          
                          ""
                            <html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <title>Search Box</title>
    <style>
    
    @import url('https://fonts.googleapis.com/css?family=Inconsolata:700');
 * {
	 margin: 0;
	 padding: 0;
	 box-sizing: border-box;
}
 html, body {
	 width: 100%;
	 height: 100%;
}
 body {
	 background: #252525;
}
 .container {
	 position: static;
	 margin: auto;
	 top: 378;
	 left: 0;
	 right: 0;
	 bottom: 0;
	 width: 300px;
	 height: 400px;
}
 .container .search {
	 position: absolute;
	 margin: auto;
	 top: 378;
	 right: 0;
	 bottom: 0;
	 left: 0;
	 width: 80px;
	 height: 80px;
	 background: #37f;
	 border-radius: 50%;
	 transition: all 1s;
	 z-index: 4;
	 box-shadow: 0 0 25px 0 rgba(0, 0, 0, 0.4);
}
 .container .search:hover {
	 cursor: pointer;
}
 .container .search::before {
	 content: "";
	 position: absolute;
	 margin: auto;
	 top: 22px;
	 right: 0;
	 bottom: 0;
	 left: 22px;
	 width: 12px;
	 height: 2px;
	 background: white;
	 transform: rotate(45deg);
	 transition: all 0.5s;
}
 .container .search::after {
	 content: "";
	 position: absolute;
	 margin: auto;
	 top: -5px;
	 right: 0;
	 bottom: 0;
	 left: -5px;
	 width: 25px;
	 height: 25px;
	 border-radius: 50%;
	 border: 2px solid white;
	 transition: all 0.5s;
}
 .container input {
	 font-family: 'Inconsolata', monospace;
	 position: absolute;
	 margin: auto;
	 top: 378;
	 right: 0;
	 bottom: 0;
	 left: 0;
	 width: 50px;
	 height: 50px;
	 outline: none;
	 border: none;
	 background: #37f;
	 color: white;
	 text-shadow: 0 0 10px #37f;
	 padding: 0 80px 0 20px;
	 border-radius: 30px;
	 box-shadow: 0 0 25px 0 #37f, 0 20px 25px 0 rgba(0, 0, 0, 0.2);
	 transition: all 1s;
	 opacity: 0;
	 z-index: 5;
	 font-weight: bolder;
	 letter-spacing: 0.1em;
}
 .container input:hover {
     
	 cursor: pointer;
}
 .container input:focus {
     top: 378px;
	 width: 300px;
	 opacity: 1;
	 cursor: text;
}
 .container input:focus ~ .search {
     
	 right: -250px;
	 background: #37f;
	 z-index: 6;
}
 .container input:focus ~ .search::before {
	 top: 0;
	 left: 0;
	 width: 25px;
}
 .container input:focus ~ .search::after {
	 top: 0;
	 left: 0;
	 width: 25px;
	 height: 2px;
	 border: none;
	 background: white;
	 border-radius: 0%;
	 transform: rotate(-45deg);
}
 .container input::placeholder {
     
	 color: white;
	 opacity: 0.5;
	 font-weight: bolder;
}
 .refrence{
	position: relative;
    top: 378px;
	right: -8%;
	font-size: 36px;
	font-family: 'Lucida Sans', 'Lucida Sans Regular', 'Lucida Grande', 'Lucida Sans Unicode', Geneva, Verdana, sans-serif;
 }
 .refrence-link{
	text-decoration: none;
	color: aliceblue;
 }
    
    
    </style>
    
</head>
<body>
    <div class="container">
        <input type="text" placeholder="Search...">
        <div class="search"></div>



        
      </div>
</body>
</html>                            

                            "></div>
    <script>
        
        const STAR_COUNT = ( window.innerWidth + window.innerHeight ) / 8,
      STAR_SIZE = 3,
      STAR_MIN_SCALE = 0.2,
      OVERFLOW_THRESHOLD = 50;

const canvas = document.querySelector( 'canvas' ),
      context = canvas.getContext( '2d' );

let scale = 1, // device pixel ratio
    width,
    height;

let stars = [];

let pointerX,
    pointerY;

let velocity = { x: 0, y: 0, tx: 0, ty: 0, z: 0.0005 };

let touchInput = false;

generate();
resize();
step();

window.onresize = resize;
canvas.onmousemove = onMouseMove;
canvas.ontouchmove = onTouchMove;
canvas.ontouchend = onMouseLeave;
document.onmouseleave = onMouseLeave;

function generate() {

   for( let i = 0; i < STAR_COUNT; i++ ) {
    stars.push({
      x: 0,
      y: 0,
      z: STAR_MIN_SCALE + Math.random() * ( 1 - STAR_MIN_SCALE )
    });
   }

}

function placeStar( star ) {

  star.x = Math.random() * width;
  star.y = Math.random() * height;

}

function recycleStar( star ) {

  let direction = 'z';

  let vx = Math.abs( velocity.x ),
	    vy = Math.abs( velocity.y );

  if( vx > 1 || vy > 1 ) {
    let axis;

    if( vx > vy ) {
      axis = Math.random() < vx / ( vx + vy ) ? 'h' : 'v';
    }
    else {
      axis = Math.random() < vy / ( vx + vy ) ? 'v' : 'h';
    }

    if( axis === 'h' ) {
      direction = velocity.x > 0 ? 'l' : 'r';
    }
    else {
      direction = velocity.y > 0 ? 't' : 'b';
    }
  }
  
  star.z = STAR_MIN_SCALE + Math.random() * ( 1 - STAR_MIN_SCALE );

  if( direction === 'z' ) {
    star.z = 0.1;
    star.x = Math.random() * width;
    star.y = Math.random() * height;
  }
  else if( direction === 'l' ) {
    star.x = -OVERFLOW_THRESHOLD;
    star.y = height * Math.random();
  }
  else if( direction === 'r' ) {
    star.x = width + OVERFLOW_THRESHOLD;
    star.y = height * Math.random();
  }
  else if( direction === 't' ) {
    star.x = width * Math.random();
    star.y = -OVERFLOW_THRESHOLD;
  }
  else if( direction === 'b' ) {
    star.x = width * Math.random();
    star.y = height + OVERFLOW_THRESHOLD;
  }

}

function resize() {

  scale = window.devicePixelRatio || 1;

  width = window.innerWidth * scale;
  height = window.innerHeight * scale;

  canvas.width = width;
  canvas.height = height;

  stars.forEach( placeStar );

}

function step() {

  context.clearRect( 0, 0, width, height );

  update();
  render();

  requestAnimationFrame( step );

}

function update() {

  velocity.tx *= 0.96;
  velocity.ty *= 0.96;

  velocity.x += ( velocity.tx - velocity.x ) * 0.07;
  velocity.y += ( velocity.ty - velocity.y ) * 0.07;

  stars.forEach( ( star ) => {

    star.x += velocity.x * star.z;
    star.y += velocity.y * star.z;

    star.x += ( star.x - width/2 ) * velocity.z * star.z;
    star.y += ( star.y - height/2 ) * velocity.z * star.z;
    star.z += velocity.z;
  
    // recycle when out of bounds
    if( star.x < -OVERFLOW_THRESHOLD || star.x > width + OVERFLOW_THRESHOLD || star.y < -OVERFLOW_THRESHOLD || star.y > height + OVERFLOW_THRESHOLD ) {
      recycleStar( star );
    }

  } );

}

function render() {

  stars.forEach( ( star ) => {

    context.beginPath();
    context.lineCap = 'round';
    context.lineWidth = STAR_SIZE * star.z * scale;
    context.strokeStyle = 'rgba(255,255,255,'+(100 + 100*Math.random())+')';

    context.beginPath();
    context.moveTo( star.x, star.y );

    var tailX = velocity.x * 2,
        tailY = velocity.y * 2;

    // stroke() wont work on an invisible line
    if( Math.abs( tailX ) < 100000 ) tailX = 0;
    if( Math.abs( tailY ) < 100000 ) tailY = 0;

    context.lineTo( star.x + tailX, star.y + tailY );

    context.stroke();

  } );

}

function movePointer( x, y ) {

  if( typeof pointerX === 'number' && typeof pointerY === 'number' ) {

    let ox = x - pointerX,
        oy = y - pointerY;

    velocity.tx = velocity.tx + ( ox / 8*scale ) * ( touchInput ? 1 : -1 );
    velocity.ty = velocity.ty + ( oy / 8*scale ) * ( touchInput ? 1 : -1 );

  }

  pointerX = x;
  pointerY = y;

}

function onMouseMove( event ) {

  touchInput = false;

  movePointer( event.clientX, event.clientY );

}

function onTouchMove( event ) {

  touchInput = true;

  movePointer( event.touches[0].clientX, event.touches[0].clientY, true );

  event.preventDefault();

}

function onMouseLeave() {

  pointerX = null;
  pointerY = null;

}

    </script>
</body>
</html>
